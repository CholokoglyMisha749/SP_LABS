.section .note.GNU-stack,"",@progbits
    .section .data

array:
    .byte 0b00010010, 0b00110100, 0b01010110, 0b01111000, 0b10011010, 0b10111100, 0b11011110, 0b11110000, 0b00100011, 0b01000101, 0b01100111, 0b10001001
array_end:

msg:
    .ascii "Количество элементов массива, двоичные коды которых содержат 0 в битах 1 и 5: %d\n"

    .section .text
    .globl main

main:
    xorl %eax, %eax        # обнуляем счётчик
    movl $array, %ebx      # загружаем адрес начала массива в регистр %ebx
    movl $array_end, %ecx  # загружаем адрес конца массива в регистр %ecx

loop_start:
    cmpl %ecx, %ebx        # сравниваем адрес текущего элемента с адресом конца массива
    je loop_end            # если достигнут конец массива, выходим из цикла

    movb (%ebx), %dl       # загружаем текущий элемент массива в регистр %dl
    andl $0b00100010, %edx # проверяем биты 1 и 5
    cmpl $0, %edx          # сравниваем результат с 0
    jne loop_next          # если биты 1 и 5 не равны 0, переходим к следующему элементу

    incl %eax              # увеличиваем счётчик

loop_next:
    incl %ebx              # переходим к следующему элементу массива
    jmp loop_start         # повторяем цикл

loop_end:
    pushl %eax             # сохраняем счётчик на стеке для передачи в функцию printf
    pushl $msg             # загружаем адрес строки формата на стек
    call printf            # вызываем функцию printf для вывода результата
    addl $8, %esp          # очищаем стек от аргументов функции printf

    xorl %eax, %eax        # возвращаем 0
    ret

